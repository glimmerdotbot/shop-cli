# Plan: `fields` Command for Resource Field Discovery

This plan adds a `fields` verb to resources, allowing users to discover which fields are available for `--select`.

## Problem

Users have no way to discover which fields can be used with `--select`:

```bash
# Works, but how would I know seo.title exists?
shop products get --id 123 --select seo.title

# No help available
shop products get --help  # doesn't list selectable fields
```

## Solution

Add a `fields` verb to resources that introspects the GraphQL type and lists available fields:

```bash
shop products fields                    # List Product fields
shop products fields seo                # List fields under Product.seo
shop products fields --depth 2          # Show nested fields up to depth 2
shop products fields --json             # Output as JSON for scripting
```

## Data Sources

The implementation can leverage two existing data sources:

### 1. LinkedTypeMap (runtime type info)

From `src/generated/admin-2026-04/index.ts`:
```typescript
import types from './types'
const typeMap = linkTypeMap(types as any)
```

The `LinkedType` structure provides:
- `name`: Type name (e.g., "Product")
- `scalar`: Array of scalar field names that can be selected without args
- `fields`: Map of all fields with their types and arguments

### 2. schema-help.ts (descriptions)

Generated by `scripts/extract-schema-help.ts`, provides:
- `queryHelp`: Descriptions and args for query operations
- Field descriptions from the GraphQL schema

However, `schema-help.ts` currently only extracts input types, enums, and root operations - not object type fields. We may need to extend it.

## Implementation

### Step 1: Extend schema-help extraction (optional but recommended)

Extend `scripts/extract-schema-help.ts` to also extract object type fields:

```typescript
// Add to extract-schema-help.ts
type ObjectFieldHelp = {
  name: string
  type: string
  description?: string
  args: OperationArgHelp[]
}

const objectTypeHelp: Record<string, ObjectFieldHelp[]> = {}

// In the AST loop, add:
if (definition.kind === Kind.OBJECT_TYPE_DEFINITION) {
  const fields = definition.fields ?? []
  objectTypeHelp[definition.name.value] = fields.map((field) => ({
    name: field.name.value,
    type: typeToString(field.type),
    description: normalizeDescription(field.description?.value),
    args: (field.arguments ?? []).map(arg => ({ /* ... */ }))
  }))
}
```

This would give us field descriptions for display.

### Step 2: Create type introspection utility

Create `src/cli/introspection/index.ts`:

```typescript
import types from '../../generated/admin-2026-04/types'
import { linkTypeMap, type LinkedType, type LinkedTypeMap } from '../../generated/admin-2026-04/runtime'

let cachedTypeMap: LinkedTypeMap | undefined

export const getTypeMap = (): LinkedTypeMap => {
  if (!cachedTypeMap) {
    cachedTypeMap = linkTypeMap(types as any)
  }
  return cachedTypeMap
}

export const getType = (name: string): LinkedType | undefined => {
  return getTypeMap()[name]
}

export type FieldInfo = {
  name: string
  typeName: string
  isScalar: boolean
  isConnection: boolean
  hasRequiredArgs: boolean
  args?: Record<string, { type: string; required: boolean }>
}

export const getFields = (typeName: string): FieldInfo[] => {
  const type = getType(typeName)
  if (!type?.fields) return []

  return Object.entries(type.fields).map(([name, field]) => {
    const targetType = field.type
    const isConnection = targetType.name?.endsWith('Connection') ?? false
    const isScalar = type.scalar?.includes(name) ?? false

    // Check for required args
    const args = field.args ?? {}
    const hasRequiredArgs = Object.values(args).some(
      arg => arg?.[1]?.endsWith('!')
    )

    return {
      name,
      typeName: targetType.name ?? 'Unknown',
      isScalar,
      isConnection,
      hasRequiredArgs,
      args: Object.entries(args).reduce((acc, [argName, arg]) => {
        if (arg) {
          acc[argName] = {
            type: arg[1] ?? arg[0].name,
            required: arg[1]?.endsWith('!') ?? false
          }
        }
        return acc
      }, {} as Record<string, { type: string; required: boolean }>)
    }
  })
}

// Traverse a dot-path and return fields at that path
export const getFieldsAtPath = (typeName: string, path: string): FieldInfo[] => {
  const parts = path.split('.')
  let currentType = typeName

  for (const part of parts) {
    const type = getType(currentType)
    const field = type?.fields?.[part]
    if (!field) return []
    currentType = field.type.name ?? ''
  }

  return getFields(currentType)
}
```

### Step 3: Add resource-to-type mapping

Create `src/cli/introspection/resources.ts`:

```typescript
// Map CLI resource names to GraphQL type names
export const resourceToType: Record<string, string> = {
  'products': 'Product',
  'product-variants': 'ProductVariant',
  'collections': 'Collection',
  'customers': 'Customer',
  'orders': 'Order',
  'draft-orders': 'DraftOrder',
  'articles': 'Article',
  'blogs': 'Blog',
  'pages': 'Page',
  'menus': 'Menu',
  'catalogs': 'Catalog',
  'markets': 'Market',
  'companies': 'Company',
  'company-contacts': 'CompanyContact',
  'company-locations': 'CompanyLocation',
  'webhooks': 'WebhookSubscription',
  'metafield-definitions': 'MetafieldDefinition',
  'metaobjects': 'Metaobject',
  'metaobject-definitions': 'MetaobjectDefinition',
  'url-redirects': 'UrlRedirect',
  'segments': 'Segment',
  'themes': 'OnlineStoreTheme',
  'validations': 'Validation',
  'cart-transforms': 'CartTransform',
  'delivery-profiles': 'DeliveryProfile',
  'delivery-customizations': 'DeliveryCustomization',
  'web-pixels': 'WebPixel',
  'fulfillment-orders': 'FulfillmentOrder',
  'fulfillments': 'Fulfillment',
  'returns': 'Return',
  'subscription-contracts': 'SubscriptionContract',
  'selling-plan-groups': 'SellingPlanGroup',
  'files': 'File',
  'publications': 'Publication',
  'inventory-items': 'InventoryItem',
  // ... complete as needed
}
```

### Step 4: Add `fields` verb handling

Option A: Add to each resource file (repetitive but explicit)

Option B: Handle globally in router.ts (preferred):

In `src/cli/router.ts`, add early handling for the `fields` verb:

```typescript
import { resourceToType } from './introspection/resources'
import { getFields, getFieldsAtPath, type FieldInfo } from './introspection'

// Near the top of runCommand, before resource-specific routing:
if (verb === 'fields') {
  const typeName = resourceToType[resource]
  if (!typeName) {
    throw new CliError(`Unknown resource: ${resource}`, 2)
  }

  const path = argv[0]  // optional path like "seo" or "variants.nodes"
  const depth = parseIntFlag(argv, '--depth') ?? 1
  const json = argv.includes('--json')

  const fields = path
    ? getFieldsAtPath(typeName, path)
    : getFields(typeName)

  if (json) {
    console.log(JSON.stringify(fields, null, 2))
  } else {
    printFieldsTable(fields, depth)
  }
  return
}
```

### Step 5: Output formatting

Create `src/cli/introspection/format.ts`:

```typescript
import type { FieldInfo } from './index'

export const printFieldsTable = (fields: FieldInfo[], maxDepth = 1) => {
  // Group fields by category
  const scalars = fields.filter(f => f.isScalar && !f.hasRequiredArgs)
  const objects = fields.filter(f => !f.isScalar && !f.isConnection && !f.hasRequiredArgs)
  const connections = fields.filter(f => f.isConnection)
  const withArgs = fields.filter(f => f.hasRequiredArgs)

  console.log('Selectable fields (use with --select):')
  console.log()

  if (scalars.length) {
    console.log('  Scalar fields:')
    for (const f of scalars) {
      console.log(`    ${f.name}`)
    }
    console.log()
  }

  if (objects.length) {
    console.log('  Object fields (use dot notation to access nested fields):')
    for (const f of objects) {
      console.log(`    ${f.name}  →  ${f.typeName}`)
    }
    console.log()
  }

  if (connections.length) {
    console.log('  Connection fields (paginated, use .nodes to access items):')
    for (const f of connections) {
      console.log(`    ${f.name}.nodes  →  ${f.typeName.replace('Connection', '')}`)
    }
    console.log()
  }

  if (withArgs.length) {
    console.log('  Fields requiring arguments (use --selection for these):')
    for (const f of withArgs) {
      const argList = Object.entries(f.args ?? {})
        .map(([name, { type, required }]) => `${name}: ${type}${required ? '' : '?'}`)
        .join(', ')
      console.log(`    ${f.name}(${argList})`)
    }
  }
}
```

### Step 6: Add to help registry

In `src/cli/help/registry.ts`, add `fields` as a standard verb:

```typescript
const fieldsVerb = (typeName: string): VerbSpec => ({
  name: 'fields',
  description: `List available fields for ${typeName}`,
  flags: [
    flag('--depth <n>', 'Show nested fields up to depth N (default: 1)'),
    flag('--json', 'Output as JSON'),
  ],
  examples: [
    `shop ${resource} fields`,
    `shop ${resource} fields seo`,
    `shop ${resource} fields --depth 2`,
  ]
})
```

## Example Output

```
$ shop products fields

Selectable fields (use with --select):

  Scalar fields:
    id
    title
    handle
    status
    createdAt
    updatedAt
    tags
    vendor
    productType
    ...

  Object fields (use dot notation to access nested fields):
    seo  →  SEO
    priceRangeV2  →  ProductPriceRangeV2
    featuredImage  →  Image
    ...

  Connection fields (paginated, use .nodes to access items):
    variants.nodes  →  ProductVariant
    media.nodes  →  Media
    collections.nodes  →  Collection
    ...

  Fields requiring arguments (use --selection for these):
    contextualPricing(context: ContextualPricingContext!)
    metafield(namespace: String!, key: String!)
    ...
```

```
$ shop products fields seo

Selectable fields (use with --select):

  Scalar fields:
    title
    description
```

## Files to Create/Modify

| File | Action |
|------|--------|
| `src/cli/introspection/index.ts` | Create - type introspection utilities |
| `src/cli/introspection/resources.ts` | Create - resource to type mapping |
| `src/cli/introspection/format.ts` | Create - output formatting |
| `src/cli/router.ts` | Modify - add `fields` verb handling |
| `src/cli/help/registry.ts` | Modify - add `fields` verb to resources |
| `scripts/extract-schema-help.ts` | Modify (optional) - extract object field descriptions |

## Testing

1. Unit tests for introspection utilities
2. Integration tests for `fields` verb on various resources
3. Verify output matches actual GraphQL schema
4. Test dot-path navigation (`shop products fields seo`)
5. Test `--json` output format

## Future Enhancements

1. **`--view all` support**: Once field introspection works, `--view all` becomes straightforward - just build a selection from all scalar fields plus 1 level of object fields

2. **Autocomplete**: The same introspection could power shell autocomplete for `--select`

3. **Validation**: Validate `--select` paths against the type system and provide helpful errors

4. **Search**: `shop products fields --search image` to find fields containing "image"
