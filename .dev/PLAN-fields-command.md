# Plan: `fields` Command for Resource Field Discovery

This plan adds a `fields` verb to resources, allowing users to discover which fields are available for `--select`.

## Problem

Users have no way to discover which fields can be used with `--select`:

```bash
# Works, but how would I know seo.title exists?
shop products get --id 123 --select seo.title

# No help available
shop products get --help  # doesn't list selectable fields
```

## Solution

Add a `fields` verb to resources that introspects the GraphQL type and lists available fields:

```bash
shop products fields                    # List Product fields
shop orders fields                      # List Order fields
```

## Data Sources

The implementation can leverage two existing data sources:

### 1. LinkedTypeMap (runtime type info)

From `src/generated/admin-2026-04/index.ts`:
```typescript
import types from './types'
const typeMap = linkTypeMap(types as any)
```

The `LinkedType` structure provides:
- `name`: Type name (e.g., "Product")
- `scalar`: Array of scalar field names that can be selected without args
- `fields`: Map of all fields with their types and arguments

### 2. schema-help.ts (descriptions)

Generated by `scripts/extract-schema-help.ts`, provides:
- `queryHelp`: Descriptions and args for query operations
- Field descriptions from the GraphQL schema

However, `schema-help.ts` currently only extracts input types, enums, and root operations - not object type fields. We may need to extend it.

## Implementation

### Step 1: Extend schema-help extraction (optional but recommended)

Extend `scripts/extract-schema-help.ts` to also extract object type fields:

```typescript
// Add to extract-schema-help.ts
type ObjectFieldHelp = {
  name: string
  type: string
  description?: string
  args: OperationArgHelp[]
}

const objectTypeHelp: Record<string, ObjectFieldHelp[]> = {}

// In the AST loop, add:
if (definition.kind === Kind.OBJECT_TYPE_DEFINITION) {
  const fields = definition.fields ?? []
  objectTypeHelp[definition.name.value] = fields.map((field) => ({
    name: field.name.value,
    type: typeToString(field.type),
    description: normalizeDescription(field.description?.value),
    args: (field.arguments ?? []).map(arg => ({ /* ... */ }))
  }))
}
```

This would give us field descriptions for display.

### Step 2: Create type introspection utility

Create `src/cli/introspection/index.ts`:

```typescript
import types from '../../generated/admin-2026-04/types'
import { linkTypeMap, type LinkedType, type LinkedTypeMap } from '../../generated/admin-2026-04/runtime'

let cachedTypeMap: LinkedTypeMap | undefined

export const getTypeMap = (): LinkedTypeMap => {
  if (!cachedTypeMap) {
    cachedTypeMap = linkTypeMap(types as any)
  }
  return cachedTypeMap
}

export const getType = (name: string): LinkedType | undefined => {
  return getTypeMap()[name]
}

export type FieldInfo = {
  name: string
  typeName: string
  isScalar: boolean
  isConnection: boolean
  hasRequiredArgs: boolean
}

export const getFields = (typeName: string): FieldInfo[] => {
  const type = getType(typeName)
  if (!type?.fields) return []

  return Object.entries(type.fields).map(([name, field]) => {
    const targetType = field.type
    const isConnection = targetType.name?.endsWith('Connection') ?? false
    const isScalar = type.scalar?.includes(name) ?? false

    // Check for required args
    const args = field.args ?? {}
    const hasRequiredArgs = Object.values(args).some(
      arg => arg?.[1]?.endsWith('!')
    )

    return {
      name,
      typeName: targetType.name ?? 'Unknown',
      isScalar,
      isConnection,
      hasRequiredArgs,
    }
  })
}
```

### Step 3: Add resource-to-type mapping

Create `src/cli/introspection/resources.ts`:

```typescript
// Map CLI resource names to GraphQL type names
export const resourceToType: Record<string, string> = {
  'products': 'Product',
  'product-variants': 'ProductVariant',
  'collections': 'Collection',
  'customers': 'Customer',
  'orders': 'Order',
  'draft-orders': 'DraftOrder',
  'articles': 'Article',
  'blogs': 'Blog',
  'pages': 'Page',
  'menus': 'Menu',
  'catalogs': 'Catalog',
  'markets': 'Market',
  'companies': 'Company',
  'company-contacts': 'CompanyContact',
  'company-locations': 'CompanyLocation',
  'webhooks': 'WebhookSubscription',
  'metafield-definitions': 'MetafieldDefinition',
  'metaobjects': 'Metaobject',
  'metaobject-definitions': 'MetaobjectDefinition',
  'url-redirects': 'UrlRedirect',
  'segments': 'Segment',
  'themes': 'OnlineStoreTheme',
  'validations': 'Validation',
  'cart-transforms': 'CartTransform',
  'delivery-profiles': 'DeliveryProfile',
  'delivery-customizations': 'DeliveryCustomization',
  'web-pixels': 'WebPixel',
  'fulfillment-orders': 'FulfillmentOrder',
  'fulfillments': 'Fulfillment',
  'returns': 'Return',
  'subscription-contracts': 'SubscriptionContract',
  'selling-plan-groups': 'SellingPlanGroup',
  'files': 'File',
  'publications': 'Publication',
  'inventory-items': 'InventoryItem',
  // ... complete as needed
}
```

### Step 4: Add `fields` verb handling

Option A: Add to each resource file (repetitive but explicit)

Option B: Handle globally in router.ts (preferred):

In `src/cli/router.ts`, add early handling for the `fields` verb:

```typescript
import { resourceToType } from './introspection/resources'
import { getFields } from './introspection'

// Near the top of runCommand, before resource-specific routing:
if (verb === 'fields') {
  const typeName = resourceToType[resource]
  if (!typeName) {
    throw new CliError(`Unknown resource: ${resource}`, 2)
  }

  const fields = getFields(typeName)
  printFieldsTable(fields)
  return
}
```

### Step 5: Output formatting

Create `src/cli/introspection/format.ts`:

```typescript
import type { FieldInfo } from './index'

export const printFieldsTable = (fields: FieldInfo[]) => {
  // Group fields by category
  const scalars = fields.filter(f => f.isScalar && !f.hasRequiredArgs)
  const objects = fields.filter(f => !f.isScalar && !f.isConnection && !f.hasRequiredArgs)
  const connections = fields.filter(f => f.isConnection)

  console.log('Selectable fields (use with --select):')
  console.log()

  if (scalars.length) {
    console.log('  Scalar fields:')
    for (const f of scalars) {
      console.log(`    ${f.name}`)
    }
    console.log()
  }

  if (objects.length) {
    console.log('  Object fields (use dot notation, e.g. --select seo.title):')
    for (const f of objects) {
      console.log(`    ${f.name}  ->  ${f.typeName}`)
    }
    console.log()
  }

  if (connections.length) {
    console.log('  Connection fields (use .nodes, e.g. --select variants.nodes.sku):')
    for (const f of connections) {
      console.log(`    ${f.name}.nodes  ->  ${f.typeName.replace('Connection', '')}`)
    }
  }
}
```

### Step 6: Add to help registry

In `src/cli/help/registry.ts`, add `fields` as a standard verb:

```typescript
const fieldsVerb: VerbSpec = {
  name: 'fields',
  description: 'List available fields for --select',
  flags: [],
  examples: []
}
```

## Example Output

```
$ shop products fields

Selectable fields (use with --select):

  Scalar fields:
    id
    title
    handle
    status
    createdAt
    updatedAt
    tags
    vendor
    productType
    ...

  Object fields (use dot notation, e.g. --select seo.title):
    seo  ->  SEO
    priceRangeV2  ->  ProductPriceRangeV2
    featuredImage  ->  Image
    ...

  Connection fields (use .nodes, e.g. --select variants.nodes.sku):
    variants.nodes  ->  ProductVariant
    media.nodes  ->  Media
    collections.nodes  ->  Collection
    ...
```

## Files to Create/Modify

| File | Action |
|------|--------|
| `src/cli/introspection/index.ts` | Create - type introspection utilities |
| `src/cli/introspection/resources.ts` | Create - resource to type mapping |
| `src/cli/introspection/format.ts` | Create - output formatting |
| `src/cli/router.ts` | Modify - add `fields` verb handling |
| `src/cli/help/registry.ts` | Modify - add `fields` verb to resources |
| `scripts/extract-schema-help.ts` | Modify (optional) - extract object field descriptions |

## Testing

1. Unit tests for introspection utilities
2. Integration tests for `fields` verb on various resources
3. Verify output matches actual GraphQL schema

## Future Enhancements

1. **`--view all` support**: Once field introspection works, `--view all` becomes straightforward - just build a selection from all scalar fields plus 1 level of object fields

2. **Autocomplete**: The same introspection could power shell autocomplete for `--select`

3. **Validation**: Validate `--select` paths against the type system and provide helpful errors

4. **Path navigation**: `shop products fields seo` to list fields under a specific path

5. **JSON output**: `shop products fields --json` for scripting
